import { graphql, GraphQLSchema } from 'graphql';

/**
 * Interface for validation result
 */
export interface ValidationResult {
  valid: boolean;
  errors: string[];
  data: any;
  query: string;
}

/**
 * Validate input fixture data types using the original schema with Query root
 *
 * This function validates that the fixture data types match the GraphQL schema's type system
 * by executing the provided query against the schema with the normalized data as the root value.
 *
 * The query and normalized data should be generated by validateInputQueryFixtureMatchWithTraversal
 * to ensure aliases are properly resolved and the structure matches.
 *
 * @param {string} query - The GraphQL query string (from validateInputQueryFixtureMatchWithTraversal)
 * @param {Record<string, any>} normalizedData - The normalized fixture data with aliases resolved
 * @param {GraphQLSchema} schema - The GraphQL schema to validate against
 * @returns {Promise<ValidationResult>} Validation result with structure:
 *   - valid: boolean - Whether the fixture data types are valid against the schema
 *   - errors: string[] - Array of error messages (empty if valid)
 *   - data: Object|null - The resulting data from query execution
 *   - query: string - The query that was executed
 */
export async function validateFixtureInputTypes(
  query: string,
  normalizedData: Record<string, any>,
  schema: GraphQLSchema
): Promise<ValidationResult> {
  const result = await graphql({
    schema,
    source: query,
    rootValue: normalizedData
  });

  return {
    valid: !result.errors || result.errors.length === 0,
    errors: result.errors?.map(err => err.message) || [],
    data: result.data || null,
    query
  };
}

